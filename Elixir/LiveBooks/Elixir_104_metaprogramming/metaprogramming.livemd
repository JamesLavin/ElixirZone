# Metaprogramming Elixir (ElixirZone - James Lavin)

## Words of encouragement

* Metaprogramming is powerful but hard/confusing/frustrating to learn.

* You won't understand it all the first (or second or third) time through.

* Learning metaprogramming is like seeing "Magic Eye" (https://www.magiceye.com/) the first time. Just keep staring and you'll eventually get it!

* Just keep watching videos and reading blog posts, Chris McCord's book, etc., and you'll slowly get there!

## Words of warning

* I'm NOT an expert. I've done metaprogramming but only a tiny fraction as often as the true experts have.

* EXPERTS are folks like these, who have done 10,000x as much metaprogramming as I have:

<!-- livebook:{"break_markdown":true} -->

![jose](images/jose_valim)

<!-- livebook:{"break_markdown":true} -->

![McCord](images/mccord.png)

<!-- livebook:{"break_markdown":true} -->

![wojtek](images/wojtek.jpg)

<!-- livebook:{"break_markdown":true} -->

Maybe one of these true experts will record an expert-level metaprogramming video???

## Additional resources

* https://elixir-lang.org/getting-started/meta/quote-and-unquote.html
* https://elixir-lang.org/getting-started/meta/macros.html
* https://repo.hex.pm/guides/elixir/meta-programming-in-elixir.epub
* https://dockyard.com/blog/2016/08/16/the-minumum-knowledge-you-need-to-start-metaprogramming-in-elixir
* https://www.theerlangelist.com/article/macros_1 (first of six blog posts by the great Saša Jurić)
* https://www.crustofcode.com/tag/macros/
* https://blog.appsignal.com/2021/09/07/an-introduction-to-metaprogramming-in-elixir.html
* https://github.com/JamesLavin/my_tech_resources/blob/master/Elixir.markdown#elixir---macros
* https://github.com/JamesLavin/my_tech_resources/blob/master/Elixir.markdown#elixir---metaprogramming

## What is a metaprogramming... and why should I care?

### Benefits

* Understand Elixir itself, most of which is created using Elixir macros (e.g., `def`, `defmodule`, `if`, `unless`, etc.)
  * Even `defmacro` is defined using `defmacro`! (Don't ask me how!)
* Extend the Elixir syntax with declarative functions that keep your code clean/sparse (e.g., `then` was only recently added, but you could have added it long ago).
* Create functions dynamically, perhaps from data in a file, e.g., functions to capitalize Unicode.
* Create your own DSLs (domain-specific languages), as many frameworks (e.g., Phoenix) do
* Avoid code duplication by extracting code you wish to `use` in multiple modules into a code block dynamically injectable via the `defmacro __using__(opts)` macro

<!-- livebook:{"break_markdown":true} -->

### Costs

* Introduces an additional layer of indirection/abstraction
* Harder to debug
* Code written as macros is harder to understand
* Metaprogramming requires thinking about both compilation-time code execution and runtime-code execution

## Marlus Saraiva: https://www.youtube.com/watch?v=ChGSLUVe5Gs

https://www.youtube.com/watch?v=ChGSLUVe5Gs

<!-- livebook:{"break_markdown":true} -->

![macro components](images/macro_components.png)

<!-- livebook:{"break_markdown":true} -->

Benefits of LiveView Surface's Macro Components:

* Extensibility via compile-time AST manipulation
* Static evaluation of body/content (warn about errors, etc.)
* Can embed other languages
* Performance optimizations

<!-- livebook:{"break_markdown":true} -->

![for vs. for](images/for_vs_for.png)

## Qing Wu (?): https://www.youtube.com/watch?v=CHHQ_xzv4pw

https://www.youtube.com/watch?v=CHHQ_xzv4pw (doesn't indicate the speaker's name)
https://www.youtube.com/watch?v=X8QfT7BNE44 is from Qing Wu, who I believe is the same presenter)

<!-- livebook:{"break_markdown":true} -->

![gentle intro](images/gentle_intro_to_macros.png)

<!-- livebook:{"break_markdown":true} -->

![simple timer](images/simple_timer.png)

## Billy Ceskavich: https://www.youtube.com/watch?v=F7qaIqcaTDc

https://www.youtube.com/watch?v=F7qaIqcaTDc

<!-- livebook:{"break_markdown":true} -->

![Billy defmacro](images/billy_defmacro2.png)

<!-- livebook:{"break_markdown":true} -->

![def is a macro](images/def_is_a_macro.png)

<!-- livebook:{"break_markdown":true} -->

![defmacro def](images/defmacro_def.png)

## Bryan Weber: https://www.youtube.com/watch?v=-mgwW3RVI50

https://www.youtube.com/watch?v=-mgwW3RVI50

<!-- livebook:{"break_markdown":true} -->

![code gen mix](images/code_gen_mix.png)

<!-- livebook:{"break_markdown":true} -->

![macros code tradeoffs](images/macros_code_tradeoffs.png)

<!-- livebook:{"break_markdown":true} -->

![defmodule unquote](images/defmodule_unquote.png)

```elixir
# Code.compile_quoted(quoted_code)

# File.write(...)
```

## Code compilation process

![compilation](images/compilation.png)

## Jesse Anderson: https://www.youtube.com/watch?v=Bo48sQDb-hk

* https://www.youtube.com/watch?v=Bo48sQDb-hk

<!-- livebook:{"break_markdown":true} -->

![compilation process](images/compilation_process.png)

<!-- livebook:{"break_markdown":true} -->

![literals & tuples](images/literals_and_tuples.png)

```elixir
if 1 + 2 == 3, do: "this", else: "that"
```

```elixir
if 1 + 2 == 3 do
  "this"
else
  "that"
end
```

```elixir
if(Kernel.==(Kernel.+(1, 2), 3), [{:do, "this"}, {:else, "that"}])
```

```elixir
quote do: if(1 + 2 == 3, do: "this", else: "that")
```

![plus](images/plus.png)

<!-- livebook:{"break_markdown":true} -->

![inlining](images/inlining.png)

```elixir
&Kernel.+/2
```

```elixir
quote do: 1 + 2
```

```elixir
quote do
  Kernel.+(1, 2)
end
```

## Environments (__ENV__ & __CALLER__)

```elixir
IO.inspect(__ENV__, limit: :infinity, printable_limit: :infinity, structs: false)
```

## Why not just use functions?

```elixir
defmodule Our do
  def if_fun(condition, do: this, else: that) do
    if(condition) do
      this
    else
      that
    end
  end
end
```

![if macro](images/if_macro.png)

```elixir
Our.if_fun 1 == 1 do
  IO.inspect("true")
else
  IO.inspect("false")
end
```

```elixir
Our.if_fun 1 == 3 do
  IO.inspect("true")
else
  IO.inspect("false")
end
```

Function args are always evaluated when the function gets called!

To avoid that, we use macros, which receive AST, which represents unevaluatable data structures that have not (yet) been evaluated.

## Nicholas J. Henry: https://www.youtube.com/watch?v=xj6yNzcGlEE

* https://www.youtube.com/watch?v=xj6yNzcGlEE
* https://www.youtube.com/watch?v=EFAgc7YqDP8

<!-- livebook:{"break_markdown":true} -->

![def vs defmacro](images/def_defmacro.png)

## Adi Iyengar: https://www.youtube.com/watch?v=oikF1Ze2Vao

* https://www.youtube.com/watch?v=oikF1Ze2Vao

<!-- livebook:{"break_markdown":true} -->

![quote as AST](images/quote_as_ast.png)

## Lizzie Paquette: https://www.youtube.com/watch?v=55-X7rSw8M0

https://www.youtube.com/watch?v=55-X7rSw8M0

<!-- livebook:{"break_markdown":true} -->

![code vs AST](images/code_vs_AST.png)

<!-- livebook:{"break_markdown":true} -->

![contexts](images/contexts.png)

<!-- livebook:{"break_markdown":true} -->

* [Presentation video & slides](https://codesync.global/media/macros-in-elixir-responsible-code-generation-cbf20/)
* [Slides (PDF)](https://codesync.global/uploads/media/activity_slides/0001/02/bf3cdf4f4c4c434fc7e97b103ccd9bceae93d76e.pdf)

<!-- livebook:{"break_markdown":true} -->

![macro contexts](images/macro_contexts.png)

```elixir
defmodule MyMod do
  defmacro who_am_i() do
    IO.inspect(__MODULE__, label: "Macro Context")
    IO.inspect(__CALLER__.module, label: "Caller Env")

    quote do
      IO.inspect(__MODULE__, label: "Caller Context")
      IO.inspect(unquote(__MODULE__), label: "Value from Macro Context")
    end
  end
end
```

```elixir
defmodule MyCaller do
  require MyMod
  MyMod.who_am_i()
end
```

## Dynamic function names

```elixir
defmodule TalkingHeads do
  @funs [ask_yourself: "How did I get here?", no_party: "No disco!"]
  # @funs [{:ask_yourself, "How did I get here?"}, {:no_party, "No disco!"}]

  for {k, v} <- @funs do
    def unquote(k)(), do: unquote(v)
  end
end
```

```elixir
TalkingHeads.ask_yourself()
```

```elixir
TalkingHeads.no_party()
```

## quote/2 transforms Elixir code --> an AST ("abstract syntax tree") data structure

```elixir
# The input `1` is ordinary Elixir code. The output `1` is that value represented as AST
quote do: 1
```

```elixir
# Elixir -> AST
# `sum(1,2)` has a different representation in AST than in Elixir code
quote do: sum(1, 2)
```

```elixir
# The AST this generates spells out -- in a nested data structure -- 
#       the exact operations to be run.
# This is a nested data structure representing operations to be run.
# This runnable specification does NOT execute those operations.
# In fact, this is not runnable as is because `sum` is not even defined.
# Executing the AST this generates will require a definition for `sum/2`:
quote do: sum(sum(sum(1, 3), sum(2, 4)), sum(5, 6))
```

```elixir
# The following cannot be evaluated because we have not provided a definition of `sum`
quote do
  sum(1, 2)
end
|> Code.eval_quoted()
```

```elixir
defmodule MyMath do
  def sum(a, b), do: a + b
end

quote do
  MyMath.sum(1, 2)
end
|> Code.eval_quoted()
```

```elixir
quote do
  MyMath.sum(MyMath.sum(MyMath.sum(1, 3), MyMath.sum(2, 4)), MyMath.sum(5, 6))
end
|> Code.eval_quoted()
```

```elixir
quote do
  import MyMath
  sum(sum(sum(1, 3), sum(2, 4)), sum(5, 6))
end
```

```elixir
quote do
  import MyMath
  sum(sum(sum(1, 3), sum(2, 4)), sum(5, 6))
end
|> Code.eval_quoted()
```

```elixir
quote do
  1 + 2
end
|> Code.eval_quoted()
```

```elixir
quote do: sum(1, 2) |> Code.eval_quoted()
```

```elixir
quote do: random_variable_name
```

```elixir
random_variable_name = 7

quote do: random_variable_name
```

```elixir
random_variable_name = 9

quote do: unquote(random_variable_name)
```

```elixir
# AST cannot be further converted
{:sum, [], [1, 2]}
```

```elixir
# Elixir -> AST -> String
quote do
  sum(1, 2)
end
|> Macro.to_string()
```

```elixir
# Using `quote do: ...`, you'll want to add parentheses or the compiler will likely
# misinterpret your code
quote(do: sum(1, 2))
|> Macro.to_string()
```

```elixir
# AST -> String
{:sum, [], [1, 2]} |> Macro.to_string()
```

```elixir
# AST -> String -> AST
{:sum, [], [1, 2]} |> Macro.to_string() |> Code.string_to_quoted() |> elem(1)
```

```elixir
# AST -> String -> AST
{:%{}, [], [{:a, 1}, {:b, 2}]} |> Macro.to_string() |> Code.string_to_quoted() |> elem(1)
```

```elixir
# AST -> String -> AST
{:{}, [], [1, 2, 3, 4]} |> Macro.to_string() |> Code.string_to_quoted() |> elem(1)
```

```elixir
# AST -> String -> AST
{:{}, [], [1, 2]} |> Macro.to_string() |> Code.string_to_quoted() |> elem(1)
```

```elixir
# AST -> String -> AST
[1, 2, 3, 4, 5] |> Macro.to_string() |> Code.string_to_quoted() |> elem(1)
```

```elixir
# AST -> String -> AST
[{:a, 1}, {:b, 2}, {:c, 3}, {:d, 4}, {:e, 5}]
|> Macro.to_string()
|> Code.string_to_quoted()
|> elem(1)
```

```elixir
# AST -> String -> AST
[a: 1, b: 2, c: 3, d: 4, e: 5] |> Macro.to_string() |> Code.string_to_quoted() |> elem(1)
```

![Brex.Struct](images/brex.struct.png)

```elixir
fields = [
  %{name: "id", type: "integer"},
  %{name: "name", type: "String.t()"},
  %{name: "status", type: "atom()"}
]

{:%{}, [], fields |> Enum.map(fn x -> {x.name, x.type} end)}
```

```elixir
fields = [
  %{name: "id", type: "integer"},
  %{name: "name", type: "String.t()"},
  %{name: "status", type: "atom()"}
]

{:%, [],
 [{:__MODULE__, [], Elixir}, {:%{}, [], fields |> Enum.map(fn x -> {x.name, x.type} end)}]}
|> Macro.to_string()
```

![mail](images/mail.png)

## Understanding DSL "magic" (including Elixir itself)

A blessing of powerful languages like Ruby and Elixir -- which provide users the ability to create domain-specific languages (DSLs) -- is that you can greatly simplify tasks via DSLs.

But DSLs come with a curse... they add layers of indirection, which can make it harder to understand and debug code that uses those DSLs.

DSLs are "magic." Magical spells are powerful but also dangerous.

Given that much of Elixir is created using the "magic" of macros and metaprogramming, you can't fully understand Elixir, leverage its full power, or help extend it without understanding macros and metaprogramming.

92% of Elixir was written in Elixir... via the magic of metaprogramming:

![elixir is written in elixir](images/elixir_is_elixir.png)

## Kernel.SpecialForms

![SpecialForms](images/special_forms.png)

<!-- livebook:{"break_markdown":true} -->

![case](images/case.png)

<!-- livebook:{"break_markdown":true} -->

![case definition](images/case_definition.png)

<!-- livebook:{"break_markdown":true} -->

^^^ We have touched the metal / hit the event horizon, beyond which we cannot proceed.

## Kernel.then/2

![then](images/then.png)

```elixir
%{}
|> then(&Map.put(&1, :baseball, "Red Sox"))
|> then(&Map.put(&1, :football, "Patriots"))
|> then(&Map.put(&1, :basketball, "Celtics"))
|> then(&Map.put(&1, :hockey, "Bruins"))
|> then(&Map.put(&1, :real_football, "Revolution"))
```

## Macro.expand_once/2

![unless macro](images/unless3.png)

```elixir
# This is compiled and then immediately evaluated
unless true, do: :a, else: :b
```

```elixir
# This is compiled and then immediately evaluated, but it throws an error
# because the variable `unset_value` has no value
unless unset_value, do: "yay", else: "boo"
```

```elixir
# This is transformed into AST but NOT immediately evaluated:
quote do
  unless unset_value, do: :a, else: :b
end
```

```elixir
quote do
  unless unset_value, do: :a, else: :b
end
|> Macro.to_string()
|> String.split("\n")
|> Enum.each(&IO.puts(&1))
```

```elixir
# This is transformed into AST but NOT immediately evaluated,
# but one round of "macro expansion" is applied:
quote do
  unless unset_value, do: :a, else: :b
end
|> Macro.expand_once(__ENV__)
```

```elixir
# We can see this more clearly:
quote do
  unless unset_value, do: :a, else: :b
end
|> Macro.expand_once(__ENV__)
|> Macro.to_string()
|> String.split("\n")
|> Enum.each(&IO.puts(&1))
```

```elixir
# This is transformed into AST but NOT immediately evaluated,
# but two rounds of "macro expansion" are applied:
quote do
  unless unset_value, do: :a, else: :b
end
|> Macro.expand_once(__ENV__)
|> Macro.expand_once(__ENV__)
|> Macro.to_string()
|> String.split("\n")
|> Enum.each(&IO.puts(&1))
```

## defmacro

* `defmacro` takes its arguments in as AST, *not* as ordinary Elixir values
* `unquote/1` (inside `quote do ... end`) transforms an AST argument into ordinary Elixir code by evaluating its current Elixir value, allowing you to pull in a value during code compilation (i.e., "at compile time") from the environment outside the `quote do ... end` block.
* Everything inside the `quote do ... end` gets transformed from ordinary Elixir code into AST

```elixir
defmodule OurThen do
  defmacro our_then(value, fun) do
    fun |> Macro.to_string() |> IO.inspect(label: "Compile time fun")
    value |> Macro.to_string() |> IO.inspect(label: "Compile time value")

    quote do
      # becomes (at compilation time below): (fn x -> x * 2 end).(1)
      unquote(fun).(unquote(value))
    end
  end
end
```

```elixir
require OurThen

1 |> OurThen.our_then(fn x -> x * 2 end)
# becomes (at compilation time):
# (fn x -> x * 2 end).(1)
```

## Kernel.tap/2

![code for tap](images/tap.png)

```elixir
%{a: 1}
|> tap(&IO.inspect(&1.a))
|> Map.update!(:a, &(&1 + 100))
```

```elixir
defmodule OurMod do
  defmacro our_tap(value, fun) do
    fun |> Macro.to_string() |> IO.inspect(label: "Compile time fun")
    value |> Macro.to_string() |> IO.inspect(label: "Compile time value")

    quote bind_quoted: [fun: fun, value: value] do
      # after bind_quoted:
      #   * `fun` will represent the uninvoked function itself
      #   * `value` will be the evaluated value
      _ = fun.(value)
      value
    end
  end
end
```

```elixir
%{a: 1} |> Map.update!(:a, &(&1 * 20))
```

```elixir
&IO.inspect(&1.a)
```

```elixir
&List.first/1
```

```elixir
quote do
  &List.first/1
end
|> Macro.to_string()
```

```elixir
require OurMod

%{a: 1}
|> Map.update!(:a, &(&1 * 20))
|> OurMod.our_tap(&IO.inspect(&1.a))
|> Map.update!(:a, &(&1 + 100))
```

## Kernel.SpecialForms

In a previous episode, I wasn't clear on the difference between Kernel & Kernel.SpecialForms.

I've since learned that macros in Kernel are expanded while macros in Kernel.SpecialForms are, well, special, and don't have documented implementations.

Here's an example, the `for` comprehension. The documentation provides a LONG description and good examples:

<!-- livebook:{"break_markdown":true} -->

![for comprehension](images/for.png)

<!-- livebook:{"break_markdown":true} -->

The documentation is about 150 lines long, but here's the entire documented "implementation":

![defmacro for](images/defmacro_for.png)

It has a secret (?) implementation.

## Code.string_to_quoted/2

Code.string_to_quoted/2 converts a string into AST (the "abstract syntax tree" representation of that same Elixir code).

The string representation "17" converts into the INTEGER 17, not the STRING "17":

```elixir
"17" |> Code.string_to_quoted()
```

```elixir
"17" |> Code.string_to_quoted() |> elem(1)
```

To represent the STRING "17" within a string, we must either pass it into `Integer.to_string()` or wrap it within (escaped) quotation marks:

```elixir
"17 |> Integer.to_string()" |> Code.string_to_quoted() |> elem(1)
```

```elixir
"\"17\"" |> Code.string_to_quoted() |> elem(1)
```

## Macro.to_string()

We can REVERSE the operation `Code.string_to_quoted()` using `Macro.to_string()`:

```elixir
"17 |> Integer.to_string()"
|> Code.string_to_quoted()
|> elem(1)
|> Macro.to_string()
```

```elixir
"\"17\""
|> Code.string_to_quoted()
|> elem(1)
|> Macro.to_string()
```

## quote(opts, block)

If you want to start with an AST representation, rather than a string representation, of your code, you can use `quote()`, (i.e., `Kernel.SpecialForms.quote(opts, block)`):

```elixir
quote do: 17
```

```elixir
quote(do: 17) |> Macro.to_string()
```

```elixir
quote(do: 17) |> Macro.to_string() |> Code.string_to_quoted!()
```

Metaprogramming is writing code that creates other code.

`quote/2` transforms Elixir code into an Elixir AST (abstract syntax tree).

Manipulating Elixir AST lets us interact with the code-generation process in a manner impossible in most languages.

For example, `Logger` can inspect code at compilation time and completely remove debugging code intended only to run in `dev` mode.

Another example: we can use macros to create DSLs (domain-specific languages), as `Ecto` and `Phoenix` do.

We can also create new "language primitives 'missing' from Elixir," like `while`. Elixir primitives like `defmodule`, `def`, and `if` are all macros, not ordinary functions.

```elixir
quote do: 17 + 18
```

Structure of this 3-element tuple:
`{function call, context, [arguments]}`

All AST expressions have this shape

<!-- livebook:{"break_markdown":true} -->

`17 + 18` is syntactic sugar for `Kernel.*(17,18)`, which is why the AST has `:*` as the function, `[context: Elixir, import: Kernel]` as the context, and `[17, 18]` as arguments

```elixir
quote do: 7 + 8
```

```elixir
[7, 8]
```

```elixir
'\a\b' == [7, 8]
```

```elixir
{:+, [context: Elixir, import: Kernel], [7, 8]} ==
  {:+, [context: Elixir, import: Kernel], '\a\b'}
```

```elixir
quote do: [1000, 1001, 1002]
```

## unquote_splicing/1

```elixir
z = [4, 5, 6]
quote do: [1, 2, 3, unquote_splicing(z), 7, 8]
```

## (Aside) Weird display of charlists (character lists)

```elixir
quote do: [101, 102, 103]
```

```elixir
'efg' == [101, 102, 103]
```

```elixir
# character list (from Erlang) != string (from Elixir)
'efg' == "efg"
```

```elixir
"efg" |> IEx.Info.info()
```

```elixir
'efg' |> IEx.Info.info()
```

```elixir
[1000, 1001, 1002] |> IEx.Info.info()
```

## Macro.to_string()

```elixir
quote do: 17 + 18
```

```elixir
quote(do: 17 + 18)
|> Macro.to_string()
```

```elixir
quote do
  [1, 2, 3]
  |> Enum.map(&(&1 + 1))
end
```

```elixir
quote do
  [1, 2, 3]
  |> Enum.map(&(&1 + 1))
end
|> Macro.to_string()
```

```elixir
# The above represented a calculation without triggering the actual calculation.
# This is "lazy evaluation."
# The code for the calculation need not even be calculatable at compile time:
quote do
  [user_input_a, user_input_b, user_input_c]
  |> Enum.map(&(&1 + 1))
end
|> Macro.to_string()
```

```elixir
quote do: x * y * z
```

```elixir
quote(do: x * y * z)
|> Macro.to_string()
```

## AST literals

```elixir
33 == quote do: 33
```

```elixir
"thirty-three" == quote do: "thirty-three"
```

```elixir
:thirty_three == quote do: :thirty_three
```

```elixir
[33] == quote do: [33]
```

```elixir
{:ok, 33} == quote do: {:ok, 33}
```

## Some Elixir types that aren't passed through to AST unmodified

```elixir
quote do: %{cat: "bad", dog: "good"}
```

```elixir
# tuples with > 2 elements
quote do: {1, 2, 3}
```

```elixir
quote do: x
```

```elixir
defmodule Pizza do
end

quote do: Pizza
```

```elixir
defmodule Food.Pizza do
end

quote do: alias(Food.Pizza)
```

```elixir
quote do: Delicious
```

```elixir
defmodule Food.Cake do
end

quote do: alias(Food.Cake, as: Delicious)
```

```elixir
quote do
  def my_fun do
    7
  end
end
```

```elixir
quote do: true and false
```

```elixir
quote do: !true
```

```elixir
quote do: x in [1, 2]
```

```elixir
quote do: Code
```

```elixir
# special atom: Module name

defmodule SampleModule do
end

SampleModule == :"Elixir.SampleModule"

quote do: SampleModule
```

```elixir
quote do: :"Elixir.SampleModule"
```

```elixir
quote(do: if(true, do: 1, else: 0))
|> Macro.expand(__ENV__)
```

```elixir
quote do
  defmodule MyMod do
    def my_fun do
      7
    end
  end
end
|> Macro.expand(__ENV__)
```

## Why aren't 2-element tuples modified?

Keeping 2-element tuples unchanged in their AST representations makes keyword lists much easier to read:

```elixir
quote do: [{:red_sox, :good}, {:yankees, :evil}]
```

```elixir
quote do: [red_sox: :good, yankees: :evil]
```

The above is much cleaner AST than this:

```elixir
quote do: [{:red_sox, :good, :fenway_park}, {:yankees, :evil, :yankees_stadium}]
```

## Code.eval_quoted(quoted, binding, opts)

```elixir
quote(do: 17 + 18) |> Code.eval_quoted()
```

```elixir
quote do
  17 + 18
end
|> Code.eval_quoted()
|> elem(0)
```

```elixir
quote(do: 357 + 9) |> Code.eval_quoted()
```

## Deeply nested AST

```elixir
quote do
  1 + 2 + 3 + 4 + 5 + 6
end
|> IO.inspect()
```

An Elixir program in its AST representation is a large (but structurally simple) tree of nested 3-element tuples

## Variables & macro hygeine

```elixir
quote do
  x
end
```

Whatever happened outside `quote` is invisible inside `quote`

```elixir
x = 3

quote do
  x
end
```

To explicitly pull values from outside `quote` into it (at compile time), you can use `unquote/1`:

```elixir
x = 3

quote do
  unquote(x)
end
```

```elixir
y = 7
quote do: unquote(y)
```

To explicitly pull values from outside `quote` into it (at runtime), you can use `var!/1`.

Here I'm also passing in an optional keyword list for use only when evaluating this particular quoted expression:

```elixir
Code.eval_quoted(
  quote do
    var!(x)
  end,
  x: 17
)
```

The above has NOT changed the value of `x` outside of the quoted expression:

```elixir
x
```

```elixir
x = 3
y = 4

quote do
  unquote(x) + unquote(y)
end
```

```elixir
x = 3
y = 4

quote do
  unquote(x) + unquote(y)
end
|> Code.eval_quoted()
|> elem(0)
```

```elixir
x = 3
y = 4

quote do
  x = unquote(x)
  y = unquote(y)
  x = x * x
  y = y * y
  x + y
end
|> Code.eval_quoted()
|> elem(0)
```

What happens inside `quote` stays inside `quote`.

`x` and `y` are still `3` and `4`, not `9` and `16`

```elixir
%{x: x, y: y}
```

## Break macro hygeine at runtime with var!/1

If you *want* your macro to modify a variable's value outside the macro, you can do so by assigning to `var!(x)`:

```elixir
x = 3
y = 4

defmodule MyMultiply do
  defmacro mult(x, y) do
    quote do
      var!(x) = unquote(x) * unquote(x)
      var!(y) = unquote(y) * unquote(y)
      var!(x) + var!(y)
    end
  end
end
```

The return value is still 25:

```elixir
require MyMultiply

MyMultiply.mult(x, y)
|> Code.eval_quoted()
```

But we have now permanently changed the values bound to the variables `x` and `y` in the scope outside the macro:

```elixir
%{x: x, y: y}
```

## quote bind_quoted

In the above example, we called `unquote(x)` twice and `unquote(y)` twice.

This is a bad practice. One reason why is inefficiency. More importantly, if the parameter passed into `unquote/1` is an impure function, you will be evaluating it multiple times.

This would be highly inefficient if the expression were, say, a database lookup.

It could be disastrous if the expression included a side effect like `fire_the_missiles()`!

<!-- livebook:{"break_markdown":true} -->

The preferred way to bind variables is using `bind_quoted`.

We can (and should) rewrite the module above as follows:

```elixir
x = 3
y = 4

defmodule MyMultiply2 do
  defmacro mult(x, y) do
    quote bind_quoted: [x: x, y: y] do
      var!(x) = x * x
      var!(y) = y * y
      var!(x) + var!(y)
    end
  end
end
```

```elixir
require MyMultiply2

MyMultiply2.mult(x, y)
|> Code.eval_quoted()
```

Because we chose to assign `x * x` to `var!(x)`, rather than to `x` and `y * y` to `var!(y)`, rather than to `y`, we permanently modified these values outside the context of the macro. We could easily avoid `var!/1` to preserve macro hygeine.

```elixir
%{x: x, y: y}
```

## Macros

Very heavily inspired by p. 6 of Chris McCord's "Metaprogramming Elixir"

<!-- livebook:{"break_markdown":true} -->

Chris writes "Rule 1: Don't Write Macros" because "macros can make programs difficult to debug and reason about."

<!-- livebook:{"break_markdown":true} -->

Macros receive AST and return AST. In other words, macros transform ASTs

```elixir
defmodule LogMath do
  defmacro log({:+, ctx, [left_arg, right_arg]}) do
    quote do
      require Logger
      left = unquote(left_arg)
      right = unquote(right_arg)
      Logger.debug("received '#{left} + #{right}'")
      unquote(ctx) |> IO.inspect(label: "ctx")
      left + right
    end
  end

  defmacro log({op, ctx, args}) do
    quote bind_quoted: [op: op, ctx: ctx, args: args] do
      IO.inspect(op, label: "op")
      IO.inspect(ctx, label: "ctx")
      IO.inspect(args, label: "args")
    end
  end

  defmacro log2({op, ctx, [left_arg, right_arg]}) when op in [:+, :-, :*, :/] do
    quote bind_quoted: [op: op, left: left_arg, right: right_arg, ctx: ctx] do
      require Logger
      # left = unquote(left_arg)
      # right = unquote(right_arg)
      Logger.debug("received '#{left} #{op} #{right}'")
      ctx |> IO.inspect(label: "ctx")
      # unquote(op)(left, right)
      {op, ctx, [left, right]} |> Code.eval_quoted() |> elem(0)
    end
  end

  defmacro log2({op, ctx, args}) do
    quote bind_quoted: [op: op, ctx: ctx, args: args] do
      IO.inspect(op, label: "op")
      IO.inspect(ctx, label: "ctx")
      IO.inspect(args, label: "args")
    end
  end
end
```

```elixir
Kernel.+(3, 4)
```

When this code is compiled, `111 + 222` will be converted to AST -- `{:+, [context: Elixir, import: Kernel], [111, 222]}` -- and passed into `LogMath.log()`:

```elixir
require LogMath

(111 + 222)
|> LogMath.log()
```

```elixir
(333 + 444)
|> LogMath.log()
```

```elixir
# I added second defmacro clause to debug why this wasn't working:
quote do
  555 + 444
end
|> LogMath.log()
```

```elixir
quote do
  Kernel.+(555, 444)
end
|> LogMath.log()

# |> Macro.escape()
```

Why can't I pattern match against `[import: Kernel, context: Elixir]`???

```elixir
(666 - 555)
|> LogMath.log2()
```

```elixir
(666 / 3)
|> LogMath.log2()
```

## Unless & navigating Elixir documentation

![unless](images/unless.png)

<!-- livebook:{"break_markdown":true} -->

![unless2](images/unless2.png)

## Macros receive (and can pattern-match against) the AST representations of their arguments

```elixir
quote do: %{a: 1, b: 2}
```

```elixir
defmodule MyMerge do
  defmacro display({:%{}, [], _kwlist}) do
    quote do
      17
    end
  end

  # defmacro merge(first, _second) do
  #  quote do
  #    unquote(first)
  #  end
  # end
  defmacro merge({:%{}, [], first_kv_pairs}, {:%{}, [], second_kv_pairs}) do
    quote do
      first_map = unquote(first_kv_pairs) |> Enum.into(%{})
      second_map = unquote(second_kv_pairs) |> Enum.into(%{})
      Map.merge(first_map, second_map)
    end
  end
end
```

```elixir
require MyMerge

MyMerge.display(%{})
# (quote do: %{}) |> MyMerge.display()
```

```elixir
require MyMerge

first = quote do: %{a: 1, b: 2}

second = quote do: %{c: 3, d: 4}

MyMerge.merge(first, second)
```

## Module.create/3

```elixir
ast =
  quote do
    def answer_to_life, do: 42

    def unladen_swallow_airspeed, do: "African or European?"
  end

Module.create(Culture, ast, Macro.Env.location(__ENV__))

Culture.answer_to_life()
```

```elixir
Culture.unladen_swallow_airspeed()
```

## use & __using__(opts)

![use](images/use.png)

<!-- livebook:{"break_markdown":true} -->

![use2](images/use2.png)

<!-- livebook:{"break_markdown":true} -->

![use3](images/use3.png)

<!-- livebook:{"break_markdown":true} -->

![use4](images/use4.png)

<!-- livebook:{"break_markdown":true} -->

![defoverridable](images/defoverridable.png)

## register_attribute(..., accumulate: true) & @before_compile

Source: Jia Hao Woo, https://blog.appsignal.com/2021/10/26/how-to-use-macros-in-elixir.html

Chris McCord's metaprogramming book has a very similar example

<!-- livebook:{"break_markdown":true} -->

![accumulate](images/accumulate.png)
