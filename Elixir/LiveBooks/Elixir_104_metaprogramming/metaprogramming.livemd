# Metaprogramming Elixir (ElixirZone - James Lavin)

## Kernel.SpecialForms.quote(opts, block)

Metaprogramming is writing code that creates other code.

`quote/2` transforms Elixir code into an Elixir AST (abstract syntax tree).

Manipulating Elixir AST lets us interact with the code-generation process in a manner impossible in most languages.

For example, `Logger` can inspect code at compilation time and completely remove debugging code intended only to run in `dev` mode.

Another example: we can use macros to create DSLs (domain-specific languages), as `Ecto` and `Phoenix` do.

We can also create new "language primitives 'missing' from Elixir," like `while`. Elixir primitives like `defmodule`, `def`, and `if` are all macros, not ordinary functions.

```elixir
quote do: 17 + 18
```

Structure of this 3-element tuple:
`{function call, context, [arguments]}`

All AST expressions have this shape

<!-- livebook:{"break_markdown":true} -->

`17 + 18` is syntactic sugar for `Kernel.*(17,18)`, which is why the AST has `:*` as the function, `[context: Elixir, import: Kernel]` as the context, and `[17, 18]` as arguments

```elixir
quote do: 7 + 8
```

```elixir
[7, 8]
```

```elixir
'\a\b' == [7, 8]
```

```elixir
{:+, [context: Elixir, import: Kernel], [7, 8]} ==
  {:+, [context: Elixir, import: Kernel], '\a\b'}
```

```elixir
quote do: [1000, 1001, 1002]
```

## (Aside) Weird display of charlists (character lists)

```elixir
quote do: [101, 102, 103]
```

```elixir
'efg' == [101, 102, 103]
```

```elixir
# character list (from Erlang) != string (from Elixir)
'efg' == "efg"
```

```elixir
"efg" |> IEx.Info.info()
```

```elixir
'efg' |> IEx.Info.info()
```

```elixir
[1000, 1001, 1002] |> IEx.Info.info()
```

## AST literals

```elixir
33 == quote do: 33
```

```elixir
"thirty-three" == quote do: "thirty-three"
```

```elixir
:thirty_three == quote do: :thirty_three
```

```elixir
[33] == quote do: [33]
```

```elixir
{:ok, 33} == quote do: {:ok, 33}
```

## Some Elixir types that aren't passed through to AST unmodified

```elixir
quote do: %{cat: "bad", dog: "good"}
```

```elixir
# tuples with > 2 elements
quote do: {1, 2, 3}
```

```elixir
quote do: true and false
```

```elixir
quote do: !true
```

```elixir
quote do: x in [1, 2]
```

```elixir
quote do: Code
```

```elixir
# special atom: Module name

defmodule SampleModule do
end

SampleModule == :"Elixir.SampleModule"

quote do: SampleModule
```

```elixir
quote do: :"Elixir.SampleModule"
```

## Code.eval_quoted(quoted, binding, opts)

```elixir
quote(do: 17 + 18) |> Code.eval_quoted()
```

```elixir
quote do
  17 + 18
end
|> Code.eval_quoted()
|> elem(0)
```

```elixir
quote(do: 357 + 9) |> Code.eval_quoted()
```

## Deeply nested AST

```elixir
quote do
  1 + 2 + 3 + 4 + 5 + 6
end
|> IO.inspect()
```

An Elixir program in its AST representation is a large (but structurally simple) tree of nested 3-element tuples

## Variables & macro hygeine

```elixir
quote do
  x
end
```

Whatever happened outside `quote` is invisible inside `quote`

```elixir
x = 3

quote do
  x
end
```

To explicitly pull values from outside `quote` into it (at compile time), you can use `unquote/1`:

```elixir
x = 3

quote do
  unquote(x)
end
```

To explicitly pull values from outside `quote` into it (at runtime), you can use `var!/1`.

Here I'm also passing in an optional keyword list for use only when evaluating this particular quoted expression:

```elixir
Code.eval_quoted(
  quote do
    var!(x)
  end,
  x: 17
)
```

The above has NOT changed the value of `x` outside of the quoted expression:

```elixir
x
```

```elixir
x = 3
y = 4

quote do
  unquote(x) + unquote(y)
end
```

```elixir
x = 3
y = 4

quote do
  unquote(x) + unquote(y)
end
|> Code.eval_quoted()
|> elem(0)
```

```elixir
x = 3
y = 4

quote do
  x = unquote(x)
  y = unquote(y)
  x = x * x
  y = y * y
  x + y
end
|> Code.eval_quoted()
|> elem(0)
```

What happens inside `quote` stays inside `quote`.

`x` and `y` are still `3` and `4`, not `9` and `16`

```elixir
%{x: x, y: y}
```

## Break macro hygeine at runtime with var!/1

If you *want* your macro to modify a variable's value outside the macro, you can do so by assigning to `var!(x)`:

```elixir
x = 3
y = 4

defmodule MyMultiply do
  defmacro mult(x, y) do
    quote do
      var!(x) = unquote(x) * unquote(x)
      var!(y) = unquote(y) * unquote(y)
      var!(x) + var!(y)
    end
  end
end
```

The return value is still 25:

```elixir
require MyMultiply

MyMultiply.mult(x, y)
|> Code.eval_quoted()
```

But we have now permanently changed the values bound to the variables `x` and `y` in the scope outside the macro:

```elixir
%{x: x, y: y}
```

## quote bind_quoted

In the above example, we called `unquote(x)` twice and `unquote(y)` twice.

This is a bad practice. One reason why is inefficiency. More importantly, if the parameter passed into `unquote/1` is an impure function, you will be evaluating it multiple times.

This would be highly inefficient if the expression were, say, a database lookup.

It could be disastrous if the expression included a side effect like `fire_the_missiles()`!

<!-- livebook:{"break_markdown":true} -->

The preferred way to bind variables is using `bind_quoted`.

We can (and should) rewrite the module above as follows:

```elixir
x = 3
y = 4

defmodule MyMultiply2 do
  defmacro mult(x, y) do
    quote bind_quoted: [x: x, y: y] do
      var!(x) = x * x
      var!(y) = y * y
      var!(x) + var!(y)
    end
  end
end
```

```elixir
require MyMultiply2

MyMultiply2.mult(x, y)
|> Code.eval_quoted()
```

Because we chose to assign `x * x` to `var!(x)`, rather than to `x` and `y * y` to `var!(y)`, rather than to `y`, we permanently modified these values outside the context of the macro. We could easily avoid `var!/1` to preserve macro hygeine.

```elixir
%{x: x, y: y}
```

## Macros

Very heavily inspired by p. 6 of Chris McCord's "Metaprogramming Elixir"

<!-- livebook:{"break_markdown":true} -->

Chris writes "Rule 1: Don't Write Macros" because "macros can make programs difficult to debug and reason about."

<!-- livebook:{"break_markdown":true} -->

Macros receive AST and return AST. In other words, macros transform ASTs

```elixir
defmodule LogMath do
  defmacro log({:+, ctx, [left_arg, right_arg]}) do
    quote do
      require Logger
      left = unquote(left_arg)
      right = unquote(right_arg)
      Logger.debug("received '#{left} + #{right}'")
      unquote(ctx) |> IO.inspect()
      left + right
    end
  end
end
```

When this code is compiled, `111 + 222` will be converted to AST -- `{:+, [context: Elixir, import: Kernel], [111, 222]}` -- and passed into `LogMath.log()`:

```elixir
require LogMath

(111 + 222)
|> LogMath.log()
```

```elixir
quote do
  333 + 444
end
|> LogMath.log()
```

Why can't I pattern match against `[import: Kernel, context: Elixir]`???

## Unless & navigating Elixir documentation

![unless](images/unless.png)

<!-- livebook:{"break_markdown":true} -->

![unless2](images/unless2.png)

## Macros receive the AST representations of their arguments

```elixir
quote do: %{a: 1, b: 2}
```

```elixir
defmodule MyMerge do
  defmacro display({:%{}, [], _kwlist}) do
    quote do
      17
    end
  end

  # defmacro merge(first, _second) do
  #  quote do
  #    unquote(first)
  #  end
  # end
  defmacro merge({:%{}, [], first_kv_pairs}, {:%{}, [], second_kv_pairs}) do
    quote do
      first_map = unquote(first_kv_pairs) |> Enum.into(%{})
      second_map = unquote(second_kv_pairs) |> Enum.into(%{})
      Map.merge(first_map, second_map)
    end
  end
end
```

```elixir
require MyMerge

MyMerge.display(%{})
# (quote do: %{}) |> MyMerge.display()
```

```elixir
require MyMerge

first = quote do: %{a: 1, b: 2}

second = quote do: %{c: 3, d: 4}

MyMerge.merge(first, second)
```
