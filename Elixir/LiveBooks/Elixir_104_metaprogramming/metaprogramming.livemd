# Metaprogramming Elixir (ElixirZone - James Lavin)

## Additional resources

* https://www.theerlangelist.com/article/macros_1 (first of six blog posts by the great Saša Jurić)
* https://github.com/JamesLavin/my_tech_resources/blob/master/Elixir.markdown#elixir---macros
* https://github.com/JamesLavin/my_tech_resources/blob/master/Elixir.markdown#elixir---metaprogramming

## What is a metaprogramming... and why should I care?

## Dynamic function names

```elixir
defmodule TalkingHeads do
  @funs [ask_yourself: "How did I get here?", no_party: "No disco!"]

  for {k, v} <- @funs do
    def unquote(k)(), do: unquote(v)
  end
end
```

```elixir
TalkingHeads.ask_yourself()
```

```elixir
TalkingHeads.no_party()
```

![mail](images/mail.png)

## Kernel.SpecialForms

In a previous episode, I wasn't clear on the difference between Kernel & Kernel.SpecialForms.

I've since learned that macros in Kernel are expanded while macros in Kernel.SpecialForms are, well, special, and don't have documented implementations.

Here's an example, the `for` comprehension. The documentation provides a LONG description and good examples:

<!-- livebook:{"break_markdown":true} -->

![for comprehension](images/for.png)

<!-- livebook:{"break_markdown":true} -->

The documentation is about 150 lines long, but here's the entire documented "implementation":

![defmacro for](images/defmacro_for.png)

It has a secret (?) implementation.

## Kernel.then/2

![then](images/then.png)

```elixir
defmodule OurThen do
  defmacro our_then(value, fun) do
    fun |> Macro.to_string() |> IO.inspect(label: "Compile time fun")
    value |> Macro.to_string() |> IO.inspect(label: "Compile time value")

    quote do
      # becomes (at compilation  time): (fn x -> x * 2 end).(1)
      unquote(fun).(unquote(value))
    end
  end
end
```

```elixir
require OurThen

1 |> OurThen.our_then(fn x -> x * 2 end)
# becomes (at compilation time):
# (fn x -> x * 2 end).(1)
```

## Kernel.tap/2

![code for tap](images/tap.png)

```elixir
%{a: 1}
|> tap(&IO.inspect(&1.a))
|> Map.update!(:a, &(&1 + 100))
```

```elixir
defmodule OurMod do
  defmacro our_tap(value, fun) do
    fun |> Macro.to_string() |> IO.inspect(label: "Compile time fun")
    value |> Macro.to_string() |> IO.inspect(label: "Compile time value")

    quote bind_quoted: [fun: fun, value: value] do
      # after bind_quoted:
      #   * `fun` will represent the uninvoked function itself
      #   * `value` will be the evaluated value
      _ = fun.(value)
      value
    end
  end
end
```

```elixir
%{a: 1} |> Map.update!(:a, &(&1 * 20))
```

```elixir
&IO.inspect(&1.a)
```

```elixir
&List.first/1
```

```elixir
quote do
  &List.first/1
end
|> Macro.to_string()
```

```elixir
require OurMod

%{a: 1}
|> Map.update!(:a, &(&1 * 20))
|> OurMod.our_tap(&IO.inspect(&1.a))
|> Map.update!(:a, &(&1 + 100))
```

## Code.string_to_quoted/2

Code.string_to_quoted/2 converts a string into AST (the "abstract syntax tree" representation of that same Elixir code).

The string representation "17" converts into the INTEGER 17, not the STRING "17":

```elixir
"17" |> Code.string_to_quoted()
```

```elixir
"17" |> Code.string_to_quoted() |> elem(1)
```

To represent the STRING "17" within a string, we must either pass it into `Integer.to_string()` or wrap it within (escaped) quotation marks:

```elixir
"17 |> Integer.to_string()" |> Code.string_to_quoted() |> elem(1)
```

```elixir
"\"17\"" |> Code.string_to_quoted() |> elem(1)
```

## Macro.to_string()

We can REVERSE the operation `Code.string_to_quoted()` using `Macro.to_string()`:

```elixir
"17 |> Integer.to_string()" |> Code.string_to_quoted() |> elem(1) |> Macro.to_string()
```

```elixir
"\"17\"" |> Code.string_to_quoted() |> elem(1) |> Macro.to_string()
```

## quote(opts, block)

If you want to start with an AST representation, rather than a string representation, of your code, you can use `quote()`, (i.e., `Kernel.SpecialForms.quote(opts, block)`):

```elixir
quote do: 17
```

```elixir
quote(do: 17) |> Macro.to_string()
```

```elixir
quote(do: 17) |> Macro.to_string() |> Code.string_to_quoted!()
```

Metaprogramming is writing code that creates other code.

`quote/2` transforms Elixir code into an Elixir AST (abstract syntax tree).

Manipulating Elixir AST lets us interact with the code-generation process in a manner impossible in most languages.

For example, `Logger` can inspect code at compilation time and completely remove debugging code intended only to run in `dev` mode.

Another example: we can use macros to create DSLs (domain-specific languages), as `Ecto` and `Phoenix` do.

We can also create new "language primitives 'missing' from Elixir," like `while`. Elixir primitives like `defmodule`, `def`, and `if` are all macros, not ordinary functions.

```elixir
quote do: 17 + 18
```

Structure of this 3-element tuple:
`{function call, context, [arguments]}`

All AST expressions have this shape

<!-- livebook:{"break_markdown":true} -->

`17 + 18` is syntactic sugar for `Kernel.*(17,18)`, which is why the AST has `:*` as the function, `[context: Elixir, import: Kernel]` as the context, and `[17, 18]` as arguments

```elixir
quote do: 7 + 8
```

```elixir
[7, 8]
```

```elixir
'\a\b' == [7, 8]
```

```elixir
{:+, [context: Elixir, import: Kernel], [7, 8]} ==
  {:+, [context: Elixir, import: Kernel], '\a\b'}
```

```elixir
quote do: [1000, 1001, 1002]
```

## unquote_splicing/1

```elixir
z = [4, 5, 6]
quote do: [1, 2, 3, unquote_splicing(z), 7, 8]
```

## (Aside) Weird display of charlists (character lists)

```elixir
quote do: [101, 102, 103]
```

```elixir
'efg' == [101, 102, 103]
```

```elixir
# character list (from Erlang) != string (from Elixir)
'efg' == "efg"
```

```elixir
"efg" |> IEx.Info.info()
```

```elixir
'efg' |> IEx.Info.info()
```

```elixir
[1000, 1001, 1002] |> IEx.Info.info()
```

## Macro.to_string()

```elixir
quote do: 17 + 18
```

```elixir
quote(do: 17 + 18)
|> Macro.to_string()
```

```elixir
quote do
  [1, 2, 3]
  |> Enum.map(&(&1 + 1))
end
```

```elixir
quote do
  [1, 2, 3]
  |> Enum.map(&(&1 + 1))
end
|> Macro.to_string()
```

```elixir
quote do: x * y * z
```

```elixir
quote(do: x * y * z)
|> Macro.to_string()
```

## AST literals

```elixir
33 == quote do: 33
```

```elixir
"thirty-three" == quote do: "thirty-three"
```

```elixir
:thirty_three == quote do: :thirty_three
```

```elixir
[33] == quote do: [33]
```

```elixir
{:ok, 33} == quote do: {:ok, 33}
```

## Some Elixir types that aren't passed through to AST unmodified

```elixir
quote do: %{cat: "bad", dog: "good"}
```

```elixir
# tuples with > 2 elements
quote do: {1, 2, 3}
```

```elixir
quote do: x
```

```elixir
defmodule Pizza do
end

quote do: Pizza
```

```elixir
defmodule Food.Pizza do
end

quote do: alias(Food.Pizza)
```

```elixir
quote do: Delicious
```

```elixir
defmodule Food.Cake do
end

quote do: alias(Food.Cake, as: Delicious)
```

```elixir
quote do
  def my_fun do
    7
  end
end
```

```elixir
quote do: true and false
```

```elixir
quote do: !true
```

```elixir
quote do: x in [1, 2]
```

```elixir
quote do: Code
```

```elixir
# special atom: Module name

defmodule SampleModule do
end

SampleModule == :"Elixir.SampleModule"

quote do: SampleModule
```

```elixir
quote do: :"Elixir.SampleModule"
```

```elixir
quote(do: if(true, do: 1, else: 0))
|> Macro.expand(__ENV__)
```

```elixir
quote do
  defmodule MyMod do
    def my_fun do
      7
    end
  end
end
|> Macro.expand(__ENV__)
```

## Why aren't 2-element tuples modified?

Keeping 2-element tuples unchanged in their AST representations makes keyword lists much easier to read:

```elixir
quote do: [{:red_sox, :good}, {:yankees, :evil}]
```

```elixir
quote do: [red_sox: :good, yankees: :evil]
```

The above is much cleaner AST than this:

```elixir
quote do: [{:red_sox, :good, :fenway_park}, {:yankees, :evil, :yankees_stadium}]
```

## Code.eval_quoted(quoted, binding, opts)

```elixir
quote(do: 17 + 18) |> Code.eval_quoted()
```

```elixir
quote do
  17 + 18
end
|> Code.eval_quoted()
|> elem(0)
```

```elixir
quote(do: 357 + 9) |> Code.eval_quoted()
```

## Deeply nested AST

```elixir
quote do
  1 + 2 + 3 + 4 + 5 + 6
end
|> IO.inspect()
```

An Elixir program in its AST representation is a large (but structurally simple) tree of nested 3-element tuples

## Variables & macro hygeine

```elixir
quote do
  x
end
```

Whatever happened outside `quote` is invisible inside `quote`

```elixir
x = 3

quote do
  x
end
```

To explicitly pull values from outside `quote` into it (at compile time), you can use `unquote/1`:

```elixir
x = 3

quote do
  unquote(x)
end
```

To explicitly pull values from outside `quote` into it (at runtime), you can use `var!/1`.

Here I'm also passing in an optional keyword list for use only when evaluating this particular quoted expression:

```elixir
Code.eval_quoted(
  quote do
    var!(x)
  end,
  x: 17
)
```

The above has NOT changed the value of `x` outside of the quoted expression:

```elixir
x
```

```elixir
x = 3
y = 4

quote do
  unquote(x) + unquote(y)
end
```

```elixir
x = 3
y = 4

quote do
  unquote(x) + unquote(y)
end
|> Code.eval_quoted()
|> elem(0)
```

```elixir
x = 3
y = 4

quote do
  x = unquote(x)
  y = unquote(y)
  x = x * x
  y = y * y
  x + y
end
|> Code.eval_quoted()
|> elem(0)
```

What happens inside `quote` stays inside `quote`.

`x` and `y` are still `3` and `4`, not `9` and `16`

```elixir
%{x: x, y: y}
```

## Break macro hygeine at runtime with var!/1

If you *want* your macro to modify a variable's value outside the macro, you can do so by assigning to `var!(x)`:

```elixir
x = 3
y = 4

defmodule MyMultiply do
  defmacro mult(x, y) do
    quote do
      var!(x) = unquote(x) * unquote(x)
      var!(y) = unquote(y) * unquote(y)
      var!(x) + var!(y)
    end
  end
end
```

The return value is still 25:

```elixir
require MyMultiply

MyMultiply.mult(x, y)
|> Code.eval_quoted()
```

But we have now permanently changed the values bound to the variables `x` and `y` in the scope outside the macro:

```elixir
%{x: x, y: y}
```

## quote bind_quoted

In the above example, we called `unquote(x)` twice and `unquote(y)` twice.

This is a bad practice. One reason why is inefficiency. More importantly, if the parameter passed into `unquote/1` is an impure function, you will be evaluating it multiple times.

This would be highly inefficient if the expression were, say, a database lookup.

It could be disastrous if the expression included a side effect like `fire_the_missiles()`!

<!-- livebook:{"break_markdown":true} -->

The preferred way to bind variables is using `bind_quoted`.

We can (and should) rewrite the module above as follows:

```elixir
x = 3
y = 4

defmodule MyMultiply2 do
  defmacro mult(x, y) do
    quote bind_quoted: [x: x, y: y] do
      var!(x) = x * x
      var!(y) = y * y
      var!(x) + var!(y)
    end
  end
end
```

```elixir
require MyMultiply2

MyMultiply2.mult(x, y)
|> Code.eval_quoted()
```

Because we chose to assign `x * x` to `var!(x)`, rather than to `x` and `y * y` to `var!(y)`, rather than to `y`, we permanently modified these values outside the context of the macro. We could easily avoid `var!/1` to preserve macro hygeine.

```elixir
%{x: x, y: y}
```

## Macros

Very heavily inspired by p. 6 of Chris McCord's "Metaprogramming Elixir"

<!-- livebook:{"break_markdown":true} -->

Chris writes "Rule 1: Don't Write Macros" because "macros can make programs difficult to debug and reason about."

<!-- livebook:{"break_markdown":true} -->

Macros receive AST and return AST. In other words, macros transform ASTs

```elixir
defmodule LogMath do
  defmacro log({:+, ctx, [left_arg, right_arg]}) do
    quote do
      require Logger
      left = unquote(left_arg)
      right = unquote(right_arg)
      Logger.debug("received '#{left} + #{right}'")
      unquote(ctx) |> IO.inspect()
      left + right
    end
  end
end
```

When this code is compiled, `111 + 222` will be converted to AST -- `{:+, [context: Elixir, import: Kernel], [111, 222]}` -- and passed into `LogMath.log()`:

```elixir
require LogMath

(111 + 222)
|> LogMath.log()
```

```elixir
quote do
  333 + 444
end
|> LogMath.log()
```

Why can't I pattern match against `[import: Kernel, context: Elixir]`???

## Unless & navigating Elixir documentation

![unless](images/unless.png)

<!-- livebook:{"break_markdown":true} -->

![unless2](images/unless2.png)

## Macros receive the AST representations of their arguments

```elixir
quote do: %{a: 1, b: 2}
```

```elixir
defmodule MyMerge do
  defmacro display({:%{}, [], _kwlist}) do
    quote do
      17
    end
  end

  # defmacro merge(first, _second) do
  #  quote do
  #    unquote(first)
  #  end
  # end
  defmacro merge({:%{}, [], first_kv_pairs}, {:%{}, [], second_kv_pairs}) do
    quote do
      first_map = unquote(first_kv_pairs) |> Enum.into(%{})
      second_map = unquote(second_kv_pairs) |> Enum.into(%{})
      Map.merge(first_map, second_map)
    end
  end
end
```

```elixir
require MyMerge

MyMerge.display(%{})
# (quote do: %{}) |> MyMerge.display()
```

```elixir
require MyMerge

first = quote do: %{a: 1, b: 2}

second = quote do: %{c: 3, d: 4}

MyMerge.merge(first, second)
```

## Module.create/3

```elixir
ast =
  quote do
    def answer_to_life, do: 42

    def unladen_swallow_airspeed, do: "African or European?"
  end

Module.create(Culture, ast, Macro.Env.location(__ENV__))

Culture.answer_to_life()
```

```elixir
Culture.unladen_swallow_airspeed()
```
